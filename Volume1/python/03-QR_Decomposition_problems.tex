 % QR via Modified Gram Schmidt.
Write a function that accepts an $m \times n$ matrix $A$ of rank $n$.
Use Algorithm \ref{Alg:modified-Gram-Schmidt} to compute the reduced QR decomposition of $A$.

Consider the following tips for implementing the algorithm.
\begin{itemize}

% \item In Python, the operation \li{a = a + b} can also be written as \li{a += b}.

\item Use \li{scipy.linalg.norm()} to compute the norm of the vector in step \ref{step:mgs-normalize}.

\item Note that steps \ref{step:mgs-mult1} and \ref{step:mgs-mult3} employ scalar multiplication or division, while step \ref{step:mgs-mult2} uses vector multiplication.

\end{itemize}

To test your function, generate test cases with NumPy's \li{np.random} module.
Verify that $R$ is upper triangular, $Q$ is orthonormal, and $QR = A$.
You may also want to compare your results to SciPy's QR factorization routine, \li{scpiy.linalg.qr()}.

\begin{lstlisting}
>>> import numpy as np
>>> from scipy import linalg as la

# Generate a random matrix and get its reduced QR decomposition via SciPy.
>>> A = np.random.random((6,4))
>>> Q,R = la.qr(A, mode="economic") # Use mode="economic" for reduced QR.
>>> print(A.shape, Q.shape, R.shape)
(6,4) (6,4) (4,4)

# Verify that R is upper triangular, Q is orthonormal, and QR = A.
>>> np.allclose(np.triu(R), R)
<<True>>
>>> np.allclose(Q.T @ Q, np.identity(4))
<<True>>
>>> np.allclose(Q @ R, A)
<<True>>
\end{lstlisting}
\label{prob:qr-via-mgs}
 % Use the QR decomposition to calculate |det(A)|.
Write a function that accepts an invertible matrix $A$.
Use the QR decomposition of $A$ and (\ref{eq:qr-determinant}) to calculate $\abs{\det(A)}$.
You may use your QR decomposition algorithm from Problem \ref{prob:qr-via-mgs} or SciPy's QR routine.
Can you implement this function in a single line?
\\(Hint: \li{np.diag()} and \li{np.prod()} may be useful.)

Check your answer against \li{la.det()}, which calculates the determinant.
 % Use the QR decomposition to solve Ax = b quickly.
Write a function that accepts an invertible $n \times n$ matrix $A$ and a vector $\b$ of length $n$.
Use the QR decomposition to solve $A\x = \b$ in the following steps:
\begin{enumerate}
    \item Compute $Q$ and $R$.
    \item Calculate $\y = Q\trp\b$.
    \item Use back substitution to solve $R\x = \y$ for $\x$.
\end{enumerate}
 % QR Decomposition via Householder Triangularization
Write a function that accepts as input a $m \times n$ matrix $A$ of rank $n$.
Use Algorithm \ref{Alg:QR-via-Householder} to compute the full QR decomposition of $A$.

Consider the following implementation details.
\begin{itemize}

\item NumPy's \li{np.sign()} is an easy way to implement the $\sign()$ operation in step \ref{step:HH-sign}.
However, \li{np.sign(0)} returns $0$, which will cause a problem in the rare case that $u_0 = 0$ (which is possible if the top left entry of $A$ is $0$ to begin with).
The following code defines a function that returns the sign of a single number, counting $0$ as positive.

\begin{lstlisting}
sign = lambda x: 1 if x >= 0 else -1
\end{lstlisting}

\item In steps \ref{step:HH-outer1} and \ref{step:HH-outer2}, the multiplication of $\u$ and $(\u\trp X)$ is an \emph{outer product} ($\x\y\trp$ instead of the usual $\x\trp\y$).
Use \li{np.outer()} instead of \li{np.dot()} to handle this correctly.

\end{itemize}

Use NumPy and SciPy to generate test cases and validate your function.

\begin{lstlisting}
>>> A = np.random.random((5, 3))
>>> Q,R = la.qr(A)                  # Get the full QR decomposition.
>>> print(A.shape, Q.shape, R.shape)
(5,3) (5,5) (5,3)
>>> np.allclose(Q @ R, A)
<<True>>
\end{lstlisting}
\label{prob:qr-via-hessenberg}
 % Reduce a matrix to upper Hessenberg form.
Write a function that accepts a nonsingular $n \times n$ matrix $A$.
Use Algorithm \ref{Alg:Upper-Hessenberg-Form} to compute the upper Hessenberg $H$ and orthogonal $Q$ satisfying $A = QHQ\trp$.

Compare your results to \li{scipy.linalg.hessenberg()}.

\begin{lstlisting}
# Generate a random matrix and get its upper Hessenberg form via SciPy.
>>> A = np.random.random((8,8))
>>> H, Q = la.hessenberg(A, calc_q=True)

# Verify that H has all zeros below the first subdiagonal and QHQ^T = A.
>>> np.allclose(np.triu(H, -1), H)
<<True>>
>>> np.allclose(Q @ H @ Q.T, A)
<<True>>
\end{lstlisting}
\label{prob:hessenberg-via-householder}

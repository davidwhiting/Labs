
{                                   # A family's info written in JSON format.
    "lastname": "Smith",            # The outer dictionary has two keys:
    "children": [                   # "lastname" and "children".
        {                           # The "children" key maps to a list of
            "name": "Timmy",        # two dictionaries, one for each of the
            "age": 8                # two children.
        },
        {
            "name": "Missy",
            "age": 5
        }
    ]
}

>>> import json

# Store info about a car in a nested dictionary.
>>> my_car = {
...     "car": {
...         "make": "Ford",
...         "color": [255, 30, 30]  },
...     "owner": "me" }

# Get the JSON message corresponding to my_car.
>>> car_str = json.dumps(my_car)
>>> car_str
<<'{"car": {"make": "Ford", "color": [255, 30, 30]}, "owner": "me"}'>>

# Load the JSON message into a Python object, reconstructing my_car.
>>> car_object = json.loads(car_str)
>>> for key in car_object:          # The loaded object is a dictionary.
...     print(key + ':', car_object[key])
...
<<car: {'make': 'Ford', 'color': [255, 30, 30]}
owner: me>>

# Write the car info to an external file.
>>> with open("my_car.json", 'w') as outfile:
...     json.dump(my_car, outfile)
...
# Read the file to check that it saved correctly.
>>> with open("my_car.json", 'r') as infile:
...     new_car = json.load(infile)
...
>>> print(new_car.keys())           # This loaded object is also a dictionary.
<<dict_keys(['car', 'owner'])>>

from mpl_toolkits.basemap import Basemap

plt.figure(figsize=(9,5))
my_map = Basemap(projection='tmerc', lat_0=34.0522, lon_0=-118.2437,
                    llcrnrlon=-118.7, llcrnrlat=33.8,
                    urcrnrlon=-118.1, urcrnrlat=34.4,
                    resolution='c', epsg=2229)
my_map.arcgisimage(service="ESRI_Imagery_World_2D")

# The 'longs' and 'lats' parameters are the coordinates of zip codes as lists.
x, y = my_map(longs, lats)
# 'averages' is a list of average water use by zip code.
my_map.scatter(x, y, s=averages, c=averages, label='Zip Code')

plt.colorbar(label='Water Use (Hundreds of Cubic Feet)')
plt.title('Water Usage in Los Angeles from 2005-2012')
plt.legend()
plt.show()

>>> class SetEncoder(json.JSONEncoder):
...     """A custom JSON encoder for Python sets."""
...     def default(self, obj):
...         if not isinstance(obj, set):
...             raise TypeError("expected a set for encoding")
...         return {"dtype": "set", "data": list(obj)}
...
# Use the custom encoder to convert a set to its custom JSON message.
>>> set_message = json.dumps(set('abca'), cls=SetEncoder)
>>> set_message
<<'{"dtype": "set", "data": ["a", "b", "c"]}'>>

# Define a custom decoder for JSON messages generated by the SetEncoder.
>>> def set_decoder(item):
...     if "dtype" in item:
...         if item["dtype"] != "set" or "data" not in item:
...             raise ValueError("expected a JSON message from SetEncoder")
...         return set(item["data"]
...     raise ValueError("expected a JSON message from SetEncoder")
...
# Use the custom decoder to convert a JSON message to the original object.
>>> json.loads(set_message, object_hook=set_decoder)
<<{'a', 'b', 'c'}>>

class TicTacToe:
    def __init__(self):
        """Initialize an empty board. The O's go first."""
        self.board = [[' ']*3 for _ in range(3)]
        self.turn, self.winner = "O", None

    def move(self, i, j):
        """Mark an O or X in the (i,j)th box and check for a winner."""
        if self.winner is not None:
            raise ValueError("the game is over!")
        elif self.board[i][j] != ' ':
            raise ValueError("space ({},{}) already taken".<<format>>(i,j))
        self.board[i][j] = self.turn

        # Determine if the game is over.
        b = self.board
        if any(sum(s == self.turn for s in r)==3 for r in b):
            self.winner = self.turn     # 3 in a row.
        elif any(sum(r[i] == self.turn for r in b)==3 for i in range(3)):
            self.winner = self.turn     # 3 in a column.
        elif b[0][0] == b[1][1] == b[2][2] == self.turn:
            self.winner = self.turn     # 3 in a diagonal.
        elif b[0][2] == b[1][1] == b[2][0] == self.turn:
            self.winner = self.turn     # 3 in a diagonal.
        else:
            self.turn = "O" if self.turn == "X" else "X"

    def empty_spaces(self):
        """Return the list of coordinates for the empty boxes."""
        return [(i,j) for i in range(3) for j in range(3)
                                        if self.board[i][j] == ' ' ]
    def __str__(self):
        return "\n---------\n".join(" | ".join(r) for r in self.board)

>>> import pickle

>>> item = pickle.dumps([1, 2, 3, 4, 5, 6])
>>> item
<<b'\x80\x03]q\x00(K\x01K\x02K\x03K\x04K\x05K\x06e.'>>

>>> pickle.loads(item)
[1, 2, 3, 4, 5, 6]

def mirror_server(server_address=("0.0.0.0", 33333)):
    """A server for reflecting strings back to clients in reverse order."""
    print("Starting mirror server on {}".<<format>>(server_address))

    # Specify the socket type, which determines how clients will connect.
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(server_address)    # Assign this socket to an address.
    server_sock.listen(1)               # Start listening for clients.

    while True:
        # Wait for a client to connect to the server.
        print("\nWaiting for a connection...")
        connection, client_address = server_sock.accept()
        try:
            # Receive data from the client.
            print("Connection accepted from {}.".<<format>>(client_address))
            in_data = connection.recv(1024).decode()    # Receive data.
            print("Received '{}' from client".<<format>>(in_data))

            # Process the received data and send something back to the client.
            out_data = in_data[::-1]
            print("Sending '{}' back to the client".<<format>>(out_data))
            connection.sendall(out_data.encode())       # Send data.

        finally:    # Make sure the connection is closed securely.
            connection.close()
            print("Closing connection from {}".<<format>>(client_address))

connection, client_address = server_sock.accept()

def mirror_client(server_address=("0.0.0.0", 33333)):
    """A client program for mirror_server()."""
    print("Attempting to connect to server at {}...".<<format>>(server_address))

    # Set up the socket to be the same type as the server.
    client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_sock.connect(server_address)    # Attempt to connect to the server.

    # Send some data from the client user to the server.
    out_data = input("Type a message to send to the server: ")
    client_sock.sendall(out_data.encode())              # Send data.

    # Wait to receive a response back from the server.
    in_data = client_sock.recv(1024).decode()           # Receive data.
    print("Received '{}' from the server".<<format>>(in_data))

    # Close the client socket.
    client_sock.close()

# TERMINAL 1
>>> mirror_server()                 # First start up the server.
Starting mirror server on ('0.0.0.0', 33333)

<<Waiting for a connection...>>         # At this point, start the client.
<<Connection accepted from ('127.0.0.1', 50679).
Received 'racecars and lollipops' from client
Sending 'spopillol dna sracecar' back to the client
Closing connection from ('127.0.0.1', 50679)

Waiting for a connection...>>
# The client program is over, but the server waits to keep serving clients.

# TERMINAL 2
>>> mirror_client()                 # Start the client after the server.
<<Attempting to connect to server at ('0.0.0.0', 33333)...
Connected!
Type a message to send: >><r<racecars and lollipops>r>
<<Received 'spopillol dna sracecar' from the server>>

>>> import requests
>>> requests.get(endpoint).json()   # Download and extract the data.

from scipy.spatial import KDTree

tree = KDTree(data)                         # Initialize the tree.
min_distance, index = tree.query(target)    # Query for a point.

>>> import http
>>> conn = http.client.HTTPConnection("www.example.net") # Establish connection
>>> conn.request("GET", "/") # Send GET request
>>> resp = conn.getresponse() # Server response message
>>> print(resp.status)
<<200>> # A status of 200 is the standard sign for successful communication
>>> print(resp.getheaders())
<<[('Cache-Control', 'max-age=604800'), ... , ('Content-Length', '1270')]>> # Header information about request
>>> print(resp.read())
<<b'<!doctype html>\n<html> ... n</html>\n'>>     # Long string with HTML from webpage
>>> conn.close() # When the request is finished, the connection is closed

>>> import requests
>>> r = requests.get("http://www.example.net")
>>> print(r.headers)
<<{'Cache-Control': 'max-age=604800', ... , 'Content-Length': '606'}>>
>>> print(r.content)
<<b'<!doctype html>\n<html> ... n</html>\n'>>

>>> r = requests.get("http://httpbin.org/get?key2=value2&key1=value1")
>>> print(r.text)
<< {
  "args": {
    "key1": "value1",
    "key2": "value2"
  },
  ...
  },
  "origin": "128.187.116.7",
  "url": "http://httpbin.org/get?key2=value2&key1=value1"
} >>
>>> r = requests.get("http://httpbin.org/get", params={'key1':'value1','key2':'value2'})
>>> print(r.url)
<< http://httpbin.org/get?key2=value2&key1=value1 >>
>>> print(r.text)
<< {
  "args": {
    "key1": "value1",
    "key2": "value2"
  },
  ...
  },
  "origin": "128.187.116.7",
  "url": "http://httpbin.org/get?key2=value2&key1=value1"
} >>

# Option 1 - Include query in the URL (? signifies start of query)
r = requests.get("http://localhost:8000?zip=91342").text
# Option 2 - Use requests library to append query to URL
r = requests.get("http://localhost:8000", params={'zip':91342}).text

>>> r = requests.put('http://httpbin.org/put', data='{key1:value1,key2:value2}')
>>> print(r.text)
<< {
  "args": {},
  "data": "{key1:value1,key2:value2}",
  "files": {},
  "form": {},
  ...
  "json": null,
  "origin": "128.187.116.7",
  "url": "http://httpbin.org/put"
} >>


>>> data = r.json()['data'] # Retrieve the sent data string
>>> print(data)
<< '{key1:value1,key2:value2}' >>
>>> print(len(data.encode())) # Show the string's length in bytes
<< 25 >>
>>> with open('request.txt', 'w') as file:
>>>         file.write(data) # Write the string to a file
>>> with open('request.txt', 'rb') as file: # Open the file as a binary stream
>>>         file.read(25) # Read the correct number of bytes
<< b'{key1:value1,key2:value2}' >>

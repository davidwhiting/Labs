
Begin implementing a \li{KalmanFilter} class by writing an initialization method that stores the transition and observation models, noise covariances, and control vector.
We provide an interface below:
\begin{lstlisting}
class KalmanFilter(object):
    def __init__(self,F,Q,H,R,u):
        """
        Initialize the dynamical system models.

        Parameters
        ----------
        F : ndarray of shape (n,n)
            The state transition model.
        Q : ndarray of shape (n,n)
            The covariance matrix for the state noise.
        H : ndarray of shape (m,n)
            The observation model.
        R : ndarray of shape (m,m)
            The covariance matric for observation noise.
        u : ndarray of shape (n,)
            The control vector.
        """
        pass
\end{lstlisting}

Work out the transition and observation models $F$ and $H$, along with the control vector $\mathbf{u}$, corresponding to the projectile.
Assume that the noise covariances are given by
\begin{align*}
Q &= 0.1 \cdot I_4\\
R &= 5000 \cdot I_2.
\end{align*}
Instantiate a \li{KalmanFilter} object with these values.

Add a method to your \li{KalmanFilter} class to generate a state and observation sequence by evolving the system from a given initial state (the function \li{numpy.random.multivariate_normal} will be useful).
To do this, implement the following:
\begin{lstlisting}
def evolve(self,x0,N):
    """
    Compute the first N states and observations generated by the Kalman system.

    Parameters
    ----------
    x0 : ndarray of shape (n,)
        The initial state.
    N : integer
        The number of time steps to evolve.

    Returns
    -------
    states : ndarray of shape (n,N)
        States 0 through N-1, given by each column.
    obs : ndarray of shape (m,N)
        Observations 0 through N-1, given by each column.
    """
    pass
\end{lstlisting}

Simulate the true and observed trajectory of a projectile with initial state
\[
\mathbf{x}_0 = \left( \begin{array}{c} 0\\ 0 \\ 300 \\ 600\end{array} \right).
\]
Approximately 1250 time steps should be sufficient for the projectile to hit the ground (i.e. for the $y$ coordinate to return to 0).
Your results should qualitatively match those given in Figure \ref{fig:evolution}.
\label{prob:simulation}

Add code to your \li{KalmanFilter} class to estimate a state sequence corresponding to a given observation sequence and initial state estimate.
Implement the following class method:
\begin{lstlisting}
def estimate(self,x,P,z):
    """
    Compute the state estimates using the Kalman filter.
    If x and P correspond to time step k, then z is a sequence of 
    observations starting at time step k+1.
    
    Parameters
    ----------
    x : ndarray of shape (n,)
        The initial state estimate.
    P : ndarray of shape (n,n)
        The initial error covariance matrix.
    z : ndarray of shape(m,N)
        Sequence of N observations (each column is an observation).

    Returns
    -------
    out : ndarray of shape (n,N)
        Sequence of state estimates (each column is an estimate).
    """
    pass
\end{lstlisting}

Calculate an initial state estimate $\widehat{\mathbf{x}}_{200}$ as follows:
For the horizontal and vertical positions, simply use the observed position at time $200$. 
For the velocity, compute the average velocity between the observations $\mathbf{z}_k$ and $\mathbf{z}_{k+1}$ for 
$k = 200,\ldots,208$, then average these 9 values and take this as the initial velocity estimate.
(Hint: the NumPy function \li{diff} is useful here.)

Using the initial state estimate, $P_{200} = 10^{6} \cdot Q$, and your Kalman filter, compute the next $600$ state estimates,
i.e. compute $\widehat{\mathbf{x}}_{201}, \ldots, \widehat{\mathbf{x}}_{800}$.
Plot these state estimates as a smooth green curve together with the radar observations (as red dots) and the entire true state sequence (as a blue curve).
Zoom in to see how well it follows the true path. Your plots should be similar to Figure \ref{fig:estimates}.
\label{prob:state_estimate}

Add a function to your class that predicts the next $k$ states given a current state estimate but in the absence of observations.
Do so by implementing the following function:
\begin{lstlisting}
def predict(self,x,k):
    """
    Predict the next k states in the absence of observations.

    Parameters
    ----------
    x : ndarray of shape (n,)
        The current state estimate.
    k : integer
        The number of states to predict.

    Returns
    -------
    out : ndarray of shape (n,k)
        The next k predicted states.
    """
    pass
\end{lstlisting}

Using the final state estimate $\widehat{\mathbf{x}}_{800}$ that you obtained in Problem \ref{prob:state_estimate}, predict the future states of 
the projectile until it hits the ground. 
Predicting approximately the next $450$ states should be sufficient.

Plot the actual state sequence together with the predicted state sequence (as a yellow curve), and observe how near the prediction is to the actual point of impact.
Your results should be similar to those shown in Figure \ref{fig:impact}.

Add a function to you class that rewinds the system from a given state estimate, returning predictions for the previous states.
Do so by implementing the following function:
\begin{lstlisting}
def rewind(self,x,k):
    """
    Predict the k states preceding the current state estimate x.
         
    Parameters
    ----------
    x : ndarray of shape (n,)
        The current state estimate.
    k : integer
        The number of preceding states to predict.

    Returns
    -------
    out : ndarray of shape (n,k)
        The k preceding predicted states.
    """    
    pass
\end{lstlisting}

Using your state estimate $\widehat{\mathbf{x}}_{250}$, predict the point of origin of the projectile along with 
all states leading up to time step $250$.
(The point of origin is the first point along the trajectory where the $y$ coordinate is $0$.)
Plot these predicted states (in cyan) together with the original state sequence.
Zoom in to see how accurate your prediction is.
Your plots should be similar to Figure \ref{fig:origin}.
\label{prob:origin_pt}

Repeat the prediction starting with $\widehat{\mathbf{x}}_{600}$.  Compare to the previous results.  Which is better?  Why?

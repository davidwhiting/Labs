
\label{prob:arma:likelihood}
Write a function that computes the log-likelihood of an $\text{ARMA}(p,q)$
model, given a time series $z_t$.

\begin{lstlisting}
def arma_likelihood(time_series, phis=array([]), thetas=array([]), mu=0.,
        sigma=1.):
    """
    Return the log-likelihood of the ARMA model parameters, given the time
    series.

    Parameters
    ----------
    time_series : ndarray of shape (n,1)
        The time series in question, z_t
    phis : ndarray of shape (p,)
        The phi parameters
    thetas : ndarray of shape (q,)
        The theta parameters
    mu : float
        The parameter mu
    sigma : float
        The standard deviation of the a_t random variables

    Returns
    -------
    log_likelihood : float
        The log-likelihood of the model
    """
    pass
\end{lstlisting}

\vspace{3mm} \noindent
When done correctly, your function should match the following output:
\begin{lstlisting}
>>> arma_likelihood(time_series_a, phis=array([0.9]), mu=17., sigma=0.4)
-77.6035
\end{lstlisting}

\label{prob:arma:mle}
Write a function that accepts a time series $\{z_t\}$ and returns the
parameters of the model that minimize the AICc, given the constraint that $p
\leq 3$, $q \leq 3$.

\begin{lstlisting}
def arma_fit(time_series):
    """
    Return the ARMA model that minimizes AICc for the given time series,
    subject to p,q <= 3.

    Parameters
    ----------
    time_series : ndarray of shape (n,1)
        The time series in question, z_t

    Returns
    -------
    phis : ndarray of shape (p,)
        The phi parameters
    thetas : ndarray of shape (q,)
        The theta parameters
    mu : float
        The parameter mu
    sigma : float
        The standard deviation of the a_t random variables
    """
    pass
\end{lstlisting}
\vspace{3mm} \noindent
Here's a hint for performing the optimization at each step, using\\ {\tt scipy.optimize.fmin}.
\begin{lstlisting}
>>> # assume p, q, and time_series are defined
>>> def f(x): # x contains the phis, thetas, mu, and sigma
>>>     return -1*arma_likelihood(time_series, phis=x[:p], thetas=x[p:p+q], mu=x[-2],sigma=x[-1])
>>> # create initial point
>>> x0 = np.zeros(p+q+2)
>>> x0[-2] = time_series.mean()
>>> x0[-1] = time_series.std()
>>> sol = op.fmin(f,x0,maxiter=10000, maxfun=10000)
\end{lstlisting}
\vspace{3mm} \noindent
The variable \li{sol} is a flat array of length $p+q+2$, whose first $p$ entries give the optimal values
for the $\phi$ polynomial, the next $q$ entries give the optimal values for the $\theta$ polynomial,
and the last two entries give the optimal values for $\mu$ and $\sigma_a$, respectively.
Notice that we defined a wrapper function $f$ to feed into the {\tt scipy.optimize.fmin} routine.
This wrapper function returns the \emph{negative} of the log likelihood, since the optimization routine we are
calling finds the minimum of a function, and we are interested in the \emph{maximum} of the log likelihood.

Your code should produce the following output, where the input data is found in
{\tt time\_series\_a.txt} (it may take a minute or so to run):
\begin{lstlisting}
>>> arma_fit(time_series_a)
(array([ 0.9087]), array([-0.5759]), 17.0652..., 0.3125...)
\end{lstlisting}

\label{prob:arma:data}
Use your solution from Problem \ref{prob:arma:mle} to fit models to the data
found in {\tt time\_series\_a.txt}, {\tt time\_series\_b.txt}, {\tt
time\_series\_c.txt}. Report the fitted parameters $p, q, \Theta$.

\label{prob:arma:forecast}
Forecast each data set ahead 20 intervals using the parameters discovered from
Problem \ref{prob:arma:data}, and plot their expected values along with the
original data set. Also plot the expected values plus and minus $\sigma_{t+k}$,
and plus and minus $2\sigma_{t+k}$ to demonstrate credible intervals.

Note that we need the values of $\hat{x}_{n|n}$ and $P_{n|n}$ to get started.
As usual, these estimates can be found using the Predict and Update recursions.
Initialize $\hat{x}_{1|0}$ and $P_{1|0}$ as before, run the recursions until you
obtain $\hat{x}_{n|n}$ and $P_{n|n}$, and then calculate the future
estimates $\hat{x}_{t+k|t}$ and $P_{t+k|t}$. Use these to calculate the expected
value and standard deviation for forecasted values (given by $H\hat{x}_{t+k|t} + \mu$
and $\sqrt{HP_{t+k|t}H^T}$, respectively).
\begin{lstlisting}
def arma_forecast(time_series, phis=array([]), thetas=array([]), mu=0.,
        sigma=1., future_periods=20):
    """
    Return forecasts for a time series modeled with the given ARMA model.

    Parameters
    ----------
    time_series : ndarray of shape (n,1)
        The time series in question, z_t
    phis : ndarray of shape (p,)
        The phi parameters
    thetas : ndarray of shape (q,)
        The theta parameters
    mu : float
        The parameter mu
    sigma : float
        The standard deviation of the a_t random variables
    future_periods : int
        The number of future periods to return

    Returns
    -------
    e_vals : ndarray of shape (future_periods,)
        The expected values of z for times n+1, ..., n+future_periods
    sigs : ndarray of shape (future_periods,)
        The standard deviations of z for times n+1, ..., n+future_periods
    """
    pass
\end{lstlisting}

\vspace{3mm} \noindent
You should get the following result:
\begin{lstlisting}
>>> arma_forecast(time_series_a, phis, thetas, mu, sigma, 4)
(array([ 17.3762,  17.3478,  17.322 ,  17.2986]),
 array([ 0.3125,  0.3294,  0.3427,  0.3533]))
\end{lstlisting}

\vspace{3mm} \noindent
Your results (when using twenty future periods) should match those in Figure \ref{fig:forecasted}.

\label{prob:arma:autocorrelation}
Write a function that computes the autocorrelation estimate described in
\ref{eq:arma:autocorrelation_estimate}, given a time series and a lag $k$.
Plot $\hat{\rho}_k$ for $1 \leq k \leq 20$ for each of the three data sets.
